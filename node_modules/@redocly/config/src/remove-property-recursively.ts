type Removed<T, Drop> = T extends Record<string, any>
  ? T extends ArrayLike<any>
    ? Array<Removed<T[number], Drop>>
    : {
        [K in Exclude<keyof T, Drop>]: Removed<T[K], Drop>;
      }
  : T;

export function removePropertyRecursively<TObject extends object, TProp extends string>(
  object: TObject,
  propToRemove: TProp,
): Removed<TObject, TProp> {
  return Object.fromEntries(
    Object.entries(object)
      .map(([key, value]) => {
        if (key === propToRemove) {
          return undefined;
        }

        if (typeof value !== 'object' || !value) {
          return [key, value];
        }

        if (Array.isArray(value)) {
          return [
            key,
            value.map((arrayItem) =>
              typeof arrayItem === 'object'
                ? removePropertyRecursively(arrayItem, propToRemove)
                : arrayItem,
            ),
          ];
        }

        return [key, removePropertyRecursively(value as Record<string, unknown>, propToRemove)];
      })
      .filter(Boolean) as [string, unknown][],
  ) as Removed<TObject, TProp>;
}
